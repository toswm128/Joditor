{"ast":null,"code":"var IDENT_RE = '[A-Za-z$_][0-9A-Za-z$_]*';\nvar KEYWORDS = [\"as\", // for exports\n\"in\", \"of\", \"if\", \"for\", \"while\", \"finally\", \"var\", \"new\", \"function\", \"do\", \"return\", \"void\", \"else\", \"break\", \"catch\", \"instanceof\", \"with\", \"throw\", \"case\", \"default\", \"try\", \"switch\", \"continue\", \"typeof\", \"delete\", \"let\", \"yield\", \"const\", \"class\", // JS handles these with a special rule\n// \"get\",\n// \"set\",\n\"debugger\", \"async\", \"await\", \"static\", \"import\", \"from\", \"export\", \"extends\"];\nvar LITERALS = [\"true\", \"false\", \"null\", \"undefined\", \"NaN\", \"Infinity\"];\nvar TYPES = [\"Intl\", \"DataView\", \"Number\", \"Math\", \"Date\", \"String\", \"RegExp\", \"Object\", \"Function\", \"Boolean\", \"Error\", \"Symbol\", \"Set\", \"Map\", \"WeakSet\", \"WeakMap\", \"Proxy\", \"Reflect\", \"JSON\", \"Promise\", \"Float64Array\", \"Int16Array\", \"Int32Array\", \"Int8Array\", \"Uint16Array\", \"Uint32Array\", \"Float32Array\", \"Array\", \"Uint8Array\", \"Uint8ClampedArray\", \"ArrayBuffer\", \"BigInt64Array\", \"BigUint64Array\", \"BigInt\"];\nvar ERROR_TYPES = [\"EvalError\", \"InternalError\", \"RangeError\", \"ReferenceError\", \"SyntaxError\", \"TypeError\", \"URIError\"];\nvar BUILT_IN_GLOBALS = [\"setInterval\", \"setTimeout\", \"clearInterval\", \"clearTimeout\", \"require\", \"exports\", \"eval\", \"isFinite\", \"isNaN\", \"parseFloat\", \"parseInt\", \"decodeURI\", \"decodeURIComponent\", \"encodeURI\", \"encodeURIComponent\", \"escape\", \"unescape\"];\nvar BUILT_IN_VARIABLES = [\"arguments\", \"this\", \"super\", \"console\", \"window\", \"document\", \"localStorage\", \"module\", \"global\" // Node.js\n];\nvar BUILT_INS = [].concat(BUILT_IN_GLOBALS, BUILT_IN_VARIABLES, TYPES, ERROR_TYPES);\n/**\n * @param {string} value\n * @returns {RegExp}\n * */\n\n/**\n * @param {RegExp | string } re\n * @returns {string}\n */\n\nfunction source(re) {\n  if (!re) return null;\n  if (typeof re === \"string\") return re;\n  return re.source;\n}\n/**\n * @param {RegExp | string } re\n * @returns {string}\n */\n\n\nfunction lookahead(re) {\n  return concat('(?=', re, ')');\n}\n/**\n * @param {...(RegExp | string) } args\n * @returns {string}\n */\n\n\nfunction concat() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  var joined = args.map(function (x) {\n    return source(x);\n  }).join(\"\");\n  return joined;\n}\n/*\nLanguage: JavaScript\nDescription: JavaScript (JS) is a lightweight, interpreted, or just-in-time compiled programming language with first-class functions.\nCategory: common, scripting\nWebsite: https://developer.mozilla.org/en-US/docs/Web/JavaScript\n*/\n\n/** @type LanguageFn */\n\n\nfunction javascript(hljs) {\n  /**\n   * Takes a string like \"<Booger\" and checks to see\n   * if we can find a matching \"</Booger\" later in the\n   * content.\n   * @param {RegExpMatchArray} match\n   * @param {{after:number}} param1\n   */\n  var hasClosingTag = function hasClosingTag(match, _ref) {\n    var after = _ref.after;\n    var tag = \"</\" + match[0].slice(1);\n    var pos = match.input.indexOf(tag, after);\n    return pos !== -1;\n  };\n\n  var IDENT_RE$1 = IDENT_RE;\n  var FRAGMENT = {\n    begin: '<>',\n    end: '</>'\n  };\n  var XML_TAG = {\n    begin: /<[A-Za-z0-9\\\\._:-]+/,\n    end: /\\/[A-Za-z0-9\\\\._:-]+>|\\/>/,\n\n    /**\n     * @param {RegExpMatchArray} match\n     * @param {CallbackResponse} response\n     */\n    isTrulyOpeningTag: function isTrulyOpeningTag(match, response) {\n      var afterMatchIndex = match[0].length + match.index;\n      var nextChar = match.input[afterMatchIndex]; // nested type?\n      // HTML should not include another raw `<` inside a tag\n      // But a type might: `<Array<Array<number>>`, etc.\n\n      if (nextChar === \"<\") {\n        response.ignoreMatch();\n        return;\n      } // <something>\n      // This is now either a tag or a type.\n\n\n      if (nextChar === \">\") {\n        // if we cannot find a matching closing tag, then we\n        // will ignore it\n        if (!hasClosingTag(match, {\n          after: afterMatchIndex\n        })) {\n          response.ignoreMatch();\n        }\n      }\n    }\n  };\n  var KEYWORDS$1 = {\n    $pattern: IDENT_RE,\n    keyword: KEYWORDS,\n    literal: LITERALS,\n    built_in: BUILT_INS\n  }; // https://tc39.es/ecma262/#sec-literals-numeric-literals\n\n  var decimalDigits = '[0-9](_?[0-9])*';\n  var frac = \"\\\\.(\".concat(decimalDigits, \")\"); // DecimalIntegerLiteral, including Annex B NonOctalDecimalIntegerLiteral\n  // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals\n\n  var decimalInteger = \"0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*\";\n  var NUMBER = {\n    className: 'number',\n    variants: [// DecimalLiteral\n    {\n      begin: \"(\\\\b(\".concat(decimalInteger, \")((\").concat(frac, \")|\\\\.)?|(\").concat(frac, \"))\") + \"[eE][+-]?(\".concat(decimalDigits, \")\\\\b\")\n    }, {\n      begin: \"\\\\b(\".concat(decimalInteger, \")\\\\b((\").concat(frac, \")\\\\b|\\\\.)?|(\").concat(frac, \")\\\\b\")\n    }, // DecimalBigIntegerLiteral\n    {\n      begin: \"\\\\b(0|[1-9](_?[0-9])*)n\\\\b\"\n    }, // NonDecimalIntegerLiteral\n    {\n      begin: \"\\\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\\\b\"\n    }, {\n      begin: \"\\\\b0[bB][0-1](_?[0-1])*n?\\\\b\"\n    }, {\n      begin: \"\\\\b0[oO][0-7](_?[0-7])*n?\\\\b\"\n    }, // LegacyOctalIntegerLiteral (does not include underscore separators)\n    // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals\n    {\n      begin: \"\\\\b0[0-7]+n?\\\\b\"\n    }],\n    relevance: 0\n  };\n  var SUBST = {\n    className: 'subst',\n    begin: '\\\\$\\\\{',\n    end: '\\\\}',\n    keywords: KEYWORDS$1,\n    contains: [] // defined later\n\n  };\n  var HTML_TEMPLATE = {\n    begin: 'html`',\n    end: '',\n    starts: {\n      end: '`',\n      returnEnd: false,\n      contains: [hljs.BACKSLASH_ESCAPE, SUBST],\n      subLanguage: 'xml'\n    }\n  };\n  var CSS_TEMPLATE = {\n    begin: 'css`',\n    end: '',\n    starts: {\n      end: '`',\n      returnEnd: false,\n      contains: [hljs.BACKSLASH_ESCAPE, SUBST],\n      subLanguage: 'css'\n    }\n  };\n  var TEMPLATE_STRING = {\n    className: 'string',\n    begin: '`',\n    end: '`',\n    contains: [hljs.BACKSLASH_ESCAPE, SUBST]\n  };\n  var JSDOC_COMMENT = hljs.COMMENT(/\\/\\*\\*(?!\\/)/, '\\\\*/', {\n    relevance: 0,\n    contains: [{\n      className: 'doctag',\n      begin: '@[A-Za-z]+',\n      contains: [{\n        className: 'type',\n        begin: '\\\\{',\n        end: '\\\\}',\n        relevance: 0\n      }, {\n        className: 'variable',\n        begin: IDENT_RE$1 + '(?=\\\\s*(-)|$)',\n        endsParent: true,\n        relevance: 0\n      }, // eat spaces (not newlines) so we can find\n      // types or variables\n      {\n        begin: /(?=[^\\n])\\s/,\n        relevance: 0\n      }]\n    }]\n  });\n  var COMMENT = {\n    className: \"comment\",\n    variants: [JSDOC_COMMENT, hljs.C_BLOCK_COMMENT_MODE, hljs.C_LINE_COMMENT_MODE]\n  };\n  var SUBST_INTERNALS = [hljs.APOS_STRING_MODE, hljs.QUOTE_STRING_MODE, HTML_TEMPLATE, CSS_TEMPLATE, TEMPLATE_STRING, NUMBER, hljs.REGEXP_MODE];\n  SUBST.contains = SUBST_INTERNALS.concat({\n    // we need to pair up {} inside our subst to prevent\n    // it from ending too early by matching another }\n    begin: /\\{/,\n    end: /\\}/,\n    keywords: KEYWORDS$1,\n    contains: [\"self\"].concat(SUBST_INTERNALS)\n  });\n  var SUBST_AND_COMMENTS = [].concat(COMMENT, SUBST.contains);\n  var PARAMS_CONTAINS = SUBST_AND_COMMENTS.concat([// eat recursive parens in sub expressions\n  {\n    begin: /\\(/,\n    end: /\\)/,\n    keywords: KEYWORDS$1,\n    contains: [\"self\"].concat(SUBST_AND_COMMENTS)\n  }]);\n  var PARAMS = {\n    className: 'params',\n    begin: /\\(/,\n    end: /\\)/,\n    excludeBegin: true,\n    excludeEnd: true,\n    keywords: KEYWORDS$1,\n    contains: PARAMS_CONTAINS\n  };\n  return {\n    name: 'Javascript',\n    aliases: ['js', 'jsx', 'mjs', 'cjs'],\n    keywords: KEYWORDS$1,\n    // this will be extended by TypeScript\n    exports: {\n      PARAMS_CONTAINS: PARAMS_CONTAINS\n    },\n    illegal: /#(?![$_A-z])/,\n    contains: [hljs.SHEBANG({\n      label: \"shebang\",\n      binary: \"node\",\n      relevance: 5\n    }), {\n      label: \"use_strict\",\n      className: 'meta',\n      relevance: 10,\n      begin: /^\\s*['\"]use (strict|asm)['\"]/\n    }, hljs.APOS_STRING_MODE, hljs.QUOTE_STRING_MODE, HTML_TEMPLATE, CSS_TEMPLATE, TEMPLATE_STRING, COMMENT, NUMBER, {\n      // object attr container\n      begin: concat(/[{,\\n]\\s*/, // we need to look ahead to make sure that we actually have an\n      // attribute coming up so we don't steal a comma from a potential\n      // \"value\" container\n      //\n      // NOTE: this might not work how you think.  We don't actually always\n      // enter this mode and stay.  Instead it might merely match `,\n      // <comments up next>` and then immediately end after the , because it\n      // fails to find any actual attrs. But this still does the job because\n      // it prevents the value contain rule from grabbing this instead and\n      // prevening this rule from firing when we actually DO have keys.\n      lookahead(concat( // we also need to allow for multiple possible comments inbetween\n      // the first key:value pairing\n      /(((\\/\\/.*$)|(\\/\\*(\\*[^/]|[^*])*\\*\\/))\\s*)*/, IDENT_RE$1 + '\\\\s*:'))),\n      relevance: 0,\n      contains: [{\n        className: 'attr',\n        begin: IDENT_RE$1 + lookahead('\\\\s*:'),\n        relevance: 0\n      }]\n    }, {\n      // \"value\" container\n      begin: '(' + hljs.RE_STARTERS_RE + '|\\\\b(case|return|throw)\\\\b)\\\\s*',\n      keywords: 'return throw case',\n      contains: [COMMENT, hljs.REGEXP_MODE, {\n        className: 'function',\n        // we have to count the parens to make sure we actually have the\n        // correct bounding ( ) before the =>.  There could be any number of\n        // sub-expressions inside also surrounded by parens.\n        begin: '(\\\\(' + '[^()]*(\\\\(' + '[^()]*(\\\\(' + '[^()]*' + '\\\\)[^()]*)*' + '\\\\)[^()]*)*' + '\\\\)|' + hljs.UNDERSCORE_IDENT_RE + ')\\\\s*=>',\n        returnBegin: true,\n        end: '\\\\s*=>',\n        contains: [{\n          className: 'params',\n          variants: [{\n            begin: hljs.UNDERSCORE_IDENT_RE,\n            relevance: 0\n          }, {\n            className: null,\n            begin: /\\(\\s*\\)/,\n            skip: true\n          }, {\n            begin: /\\(/,\n            end: /\\)/,\n            excludeBegin: true,\n            excludeEnd: true,\n            keywords: KEYWORDS$1,\n            contains: PARAMS_CONTAINS\n          }]\n        }]\n      }, {\n        // could be a comma delimited list of params to a function call\n        begin: /,/,\n        relevance: 0\n      }, {\n        className: '',\n        begin: /\\s/,\n        end: /\\s*/,\n        skip: true\n      }, {\n        // JSX\n        variants: [{\n          begin: FRAGMENT.begin,\n          end: FRAGMENT.end\n        }, {\n          begin: XML_TAG.begin,\n          // we carefully check the opening tag to see if it truly\n          // is a tag and not a false positive\n          'on:begin': XML_TAG.isTrulyOpeningTag,\n          end: XML_TAG.end\n        }],\n        subLanguage: 'xml',\n        contains: [{\n          begin: XML_TAG.begin,\n          end: XML_TAG.end,\n          skip: true,\n          contains: ['self']\n        }]\n      }],\n      relevance: 0\n    }, {\n      className: 'function',\n      beginKeywords: 'function',\n      end: /[{;]/,\n      excludeEnd: true,\n      keywords: KEYWORDS$1,\n      contains: ['self', hljs.inherit(hljs.TITLE_MODE, {\n        begin: IDENT_RE$1\n      }), PARAMS],\n      illegal: /%/\n    }, {\n      // prevent this from getting swallowed up by function\n      // since they appear \"function like\"\n      beginKeywords: \"while if switch catch for\"\n    }, {\n      className: 'function',\n      // we have to count the parens to make sure we actually have the correct\n      // bounding ( ).  There could be any number of sub-expressions inside\n      // also surrounded by parens.\n      begin: hljs.UNDERSCORE_IDENT_RE + '\\\\(' + // first parens\n      '[^()]*(\\\\(' + '[^()]*(\\\\(' + '[^()]*' + '\\\\)[^()]*)*' + '\\\\)[^()]*)*' + '\\\\)\\\\s*\\\\{',\n      // end parens\n      returnBegin: true,\n      contains: [PARAMS, hljs.inherit(hljs.TITLE_MODE, {\n        begin: IDENT_RE$1\n      })]\n    }, // hack: prevents detection of keywords in some circumstances\n    // .keyword()\n    // $keyword = x\n    {\n      variants: [{\n        begin: '\\\\.' + IDENT_RE$1\n      }, {\n        begin: '\\\\$' + IDENT_RE$1\n      }],\n      relevance: 0\n    }, {\n      // ES6 class\n      className: 'class',\n      beginKeywords: 'class',\n      end: /[{;=]/,\n      excludeEnd: true,\n      illegal: /[:\"[\\]]/,\n      contains: [{\n        beginKeywords: 'extends'\n      }, hljs.UNDERSCORE_TITLE_MODE]\n    }, {\n      begin: /\\b(?=constructor)/,\n      end: /[{;]/,\n      excludeEnd: true,\n      contains: [hljs.inherit(hljs.TITLE_MODE, {\n        begin: IDENT_RE$1\n      }), 'self', PARAMS]\n    }, {\n      begin: '(get|set)\\\\s+(?=' + IDENT_RE$1 + '\\\\()',\n      end: /\\{/,\n      keywords: \"get set\",\n      contains: [hljs.inherit(hljs.TITLE_MODE, {\n        begin: IDENT_RE$1\n      }), {\n        begin: /\\(\\)/\n      }, // eat to avoid empty params\n      PARAMS]\n    }, {\n      begin: /\\$[(.]/ // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`\n\n    }]\n  };\n}\n/*\nLanguage: TypeScript\nAuthor: Panu Horsmalahti <panu.horsmalahti@iki.fi>\nContributors: Ike Ku <dempfi@yahoo.com>\nDescription: TypeScript is a strict superset of JavaScript\nWebsite: https://www.typescriptlang.org\nCategory: common, scripting\n*/\n\n/** @type LanguageFn */\n\n\nfunction typescript(hljs) {\n  var IDENT_RE$1 = IDENT_RE;\n  var NAMESPACE = {\n    beginKeywords: 'namespace',\n    end: /\\{/,\n    excludeEnd: true\n  };\n  var INTERFACE = {\n    beginKeywords: 'interface',\n    end: /\\{/,\n    excludeEnd: true,\n    keywords: 'interface extends'\n  };\n  var USE_STRICT = {\n    className: 'meta',\n    relevance: 10,\n    begin: /^\\s*['\"]use strict['\"]/\n  };\n  var TYPES = [\"any\", \"void\", \"number\", \"boolean\", \"string\", \"object\", \"never\", \"enum\"];\n  var TS_SPECIFIC_KEYWORDS = [\"type\", \"namespace\", \"typedef\", \"interface\", \"public\", \"private\", \"protected\", \"implements\", \"declare\", \"abstract\", \"readonly\"];\n  var KEYWORDS$1 = {\n    $pattern: IDENT_RE,\n    keyword: KEYWORDS.concat(TS_SPECIFIC_KEYWORDS),\n    literal: LITERALS,\n    built_in: BUILT_INS.concat(TYPES)\n  };\n  var DECORATOR = {\n    className: 'meta',\n    begin: '@' + IDENT_RE$1\n  };\n\n  var swapMode = function swapMode(mode, label, replacement) {\n    var indx = mode.contains.findIndex(function (m) {\n      return m.label === label;\n    });\n\n    if (indx === -1) {\n      throw new Error(\"can not find mode to replace\");\n    }\n\n    mode.contains.splice(indx, 1, replacement);\n  };\n\n  var tsLanguage = javascript(hljs); // this should update anywhere keywords is used since\n  // it will be the same actual JS object\n\n  Object.assign(tsLanguage.keywords, KEYWORDS$1);\n  tsLanguage.exports.PARAMS_CONTAINS.push(DECORATOR);\n  tsLanguage.contains = tsLanguage.contains.concat([DECORATOR, NAMESPACE, INTERFACE]); // TS gets a simpler shebang rule than JS\n\n  swapMode(tsLanguage, \"shebang\", hljs.SHEBANG()); // JS use strict rule purposely excludes `asm` which makes no sense\n\n  swapMode(tsLanguage, \"use_strict\", USE_STRICT);\n  var functionDeclaration = tsLanguage.contains.find(function (m) {\n    return m.className === \"function\";\n  });\n  functionDeclaration.relevance = 0; // () => {} is more typical in TypeScript\n\n  Object.assign(tsLanguage, {\n    name: 'TypeScript',\n    aliases: ['ts', 'tsx']\n  });\n  return tsLanguage;\n}\n\nmodule.exports = typescript;","map":{"version":3,"sources":["/Users/jominsu/Documents/GitHub/Joditor/node_modules/highlight.js/lib/languages/typescript.js"],"names":["IDENT_RE","KEYWORDS","LITERALS","TYPES","ERROR_TYPES","BUILT_IN_GLOBALS","BUILT_IN_VARIABLES","BUILT_INS","concat","source","re","lookahead","args","joined","map","x","join","javascript","hljs","hasClosingTag","match","after","tag","slice","pos","input","indexOf","IDENT_RE$1","FRAGMENT","begin","end","XML_TAG","isTrulyOpeningTag","response","afterMatchIndex","length","index","nextChar","ignoreMatch","KEYWORDS$1","$pattern","keyword","literal","built_in","decimalDigits","frac","decimalInteger","NUMBER","className","variants","relevance","SUBST","keywords","contains","HTML_TEMPLATE","starts","returnEnd","BACKSLASH_ESCAPE","subLanguage","CSS_TEMPLATE","TEMPLATE_STRING","JSDOC_COMMENT","COMMENT","endsParent","C_BLOCK_COMMENT_MODE","C_LINE_COMMENT_MODE","SUBST_INTERNALS","APOS_STRING_MODE","QUOTE_STRING_MODE","REGEXP_MODE","SUBST_AND_COMMENTS","PARAMS_CONTAINS","PARAMS","excludeBegin","excludeEnd","name","aliases","exports","illegal","SHEBANG","label","binary","RE_STARTERS_RE","UNDERSCORE_IDENT_RE","returnBegin","skip","beginKeywords","inherit","TITLE_MODE","UNDERSCORE_TITLE_MODE","typescript","NAMESPACE","INTERFACE","USE_STRICT","TS_SPECIFIC_KEYWORDS","DECORATOR","swapMode","mode","replacement","indx","findIndex","m","Error","splice","tsLanguage","Object","assign","push","functionDeclaration","find","module"],"mappings":"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","sourcesContent":["const IDENT_RE = '[A-Za-z$_][0-9A-Za-z$_]*';\nconst KEYWORDS = [\n  \"as\", // for exports\n  \"in\",\n  \"of\",\n  \"if\",\n  \"for\",\n  \"while\",\n  \"finally\",\n  \"var\",\n  \"new\",\n  \"function\",\n  \"do\",\n  \"return\",\n  \"void\",\n  \"else\",\n  \"break\",\n  \"catch\",\n  \"instanceof\",\n  \"with\",\n  \"throw\",\n  \"case\",\n  \"default\",\n  \"try\",\n  \"switch\",\n  \"continue\",\n  \"typeof\",\n  \"delete\",\n  \"let\",\n  \"yield\",\n  \"const\",\n  \"class\",\n  // JS handles these with a special rule\n  // \"get\",\n  // \"set\",\n  \"debugger\",\n  \"async\",\n  \"await\",\n  \"static\",\n  \"import\",\n  \"from\",\n  \"export\",\n  \"extends\"\n];\nconst LITERALS = [\n  \"true\",\n  \"false\",\n  \"null\",\n  \"undefined\",\n  \"NaN\",\n  \"Infinity\"\n];\n\nconst TYPES = [\n  \"Intl\",\n  \"DataView\",\n  \"Number\",\n  \"Math\",\n  \"Date\",\n  \"String\",\n  \"RegExp\",\n  \"Object\",\n  \"Function\",\n  \"Boolean\",\n  \"Error\",\n  \"Symbol\",\n  \"Set\",\n  \"Map\",\n  \"WeakSet\",\n  \"WeakMap\",\n  \"Proxy\",\n  \"Reflect\",\n  \"JSON\",\n  \"Promise\",\n  \"Float64Array\",\n  \"Int16Array\",\n  \"Int32Array\",\n  \"Int8Array\",\n  \"Uint16Array\",\n  \"Uint32Array\",\n  \"Float32Array\",\n  \"Array\",\n  \"Uint8Array\",\n  \"Uint8ClampedArray\",\n  \"ArrayBuffer\",\n  \"BigInt64Array\",\n  \"BigUint64Array\",\n  \"BigInt\"\n];\n\nconst ERROR_TYPES = [\n  \"EvalError\",\n  \"InternalError\",\n  \"RangeError\",\n  \"ReferenceError\",\n  \"SyntaxError\",\n  \"TypeError\",\n  \"URIError\"\n];\n\nconst BUILT_IN_GLOBALS = [\n  \"setInterval\",\n  \"setTimeout\",\n  \"clearInterval\",\n  \"clearTimeout\",\n\n  \"require\",\n  \"exports\",\n\n  \"eval\",\n  \"isFinite\",\n  \"isNaN\",\n  \"parseFloat\",\n  \"parseInt\",\n  \"decodeURI\",\n  \"decodeURIComponent\",\n  \"encodeURI\",\n  \"encodeURIComponent\",\n  \"escape\",\n  \"unescape\"\n];\n\nconst BUILT_IN_VARIABLES = [\n  \"arguments\",\n  \"this\",\n  \"super\",\n  \"console\",\n  \"window\",\n  \"document\",\n  \"localStorage\",\n  \"module\",\n  \"global\" // Node.js\n];\n\nconst BUILT_INS = [].concat(\n  BUILT_IN_GLOBALS,\n  BUILT_IN_VARIABLES,\n  TYPES,\n  ERROR_TYPES\n);\n\n/**\n * @param {string} value\n * @returns {RegExp}\n * */\n\n/**\n * @param {RegExp | string } re\n * @returns {string}\n */\nfunction source(re) {\n  if (!re) return null;\n  if (typeof re === \"string\") return re;\n\n  return re.source;\n}\n\n/**\n * @param {RegExp | string } re\n * @returns {string}\n */\nfunction lookahead(re) {\n  return concat('(?=', re, ')');\n}\n\n/**\n * @param {...(RegExp | string) } args\n * @returns {string}\n */\nfunction concat(...args) {\n  const joined = args.map((x) => source(x)).join(\"\");\n  return joined;\n}\n\n/*\nLanguage: JavaScript\nDescription: JavaScript (JS) is a lightweight, interpreted, or just-in-time compiled programming language with first-class functions.\nCategory: common, scripting\nWebsite: https://developer.mozilla.org/en-US/docs/Web/JavaScript\n*/\n\n/** @type LanguageFn */\nfunction javascript(hljs) {\n  /**\n   * Takes a string like \"<Booger\" and checks to see\n   * if we can find a matching \"</Booger\" later in the\n   * content.\n   * @param {RegExpMatchArray} match\n   * @param {{after:number}} param1\n   */\n  const hasClosingTag = (match, { after }) => {\n    const tag = \"</\" + match[0].slice(1);\n    const pos = match.input.indexOf(tag, after);\n    return pos !== -1;\n  };\n\n  const IDENT_RE$1 = IDENT_RE;\n  const FRAGMENT = {\n    begin: '<>',\n    end: '</>'\n  };\n  const XML_TAG = {\n    begin: /<[A-Za-z0-9\\\\._:-]+/,\n    end: /\\/[A-Za-z0-9\\\\._:-]+>|\\/>/,\n    /**\n     * @param {RegExpMatchArray} match\n     * @param {CallbackResponse} response\n     */\n    isTrulyOpeningTag: (match, response) => {\n      const afterMatchIndex = match[0].length + match.index;\n      const nextChar = match.input[afterMatchIndex];\n      // nested type?\n      // HTML should not include another raw `<` inside a tag\n      // But a type might: `<Array<Array<number>>`, etc.\n      if (nextChar === \"<\") {\n        response.ignoreMatch();\n        return;\n      }\n      // <something>\n      // This is now either a tag or a type.\n      if (nextChar === \">\") {\n        // if we cannot find a matching closing tag, then we\n        // will ignore it\n        if (!hasClosingTag(match, { after: afterMatchIndex })) {\n          response.ignoreMatch();\n        }\n      }\n    }\n  };\n  const KEYWORDS$1 = {\n    $pattern: IDENT_RE,\n    keyword: KEYWORDS,\n    literal: LITERALS,\n    built_in: BUILT_INS\n  };\n\n  // https://tc39.es/ecma262/#sec-literals-numeric-literals\n  const decimalDigits = '[0-9](_?[0-9])*';\n  const frac = `\\\\.(${decimalDigits})`;\n  // DecimalIntegerLiteral, including Annex B NonOctalDecimalIntegerLiteral\n  // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals\n  const decimalInteger = `0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*`;\n  const NUMBER = {\n    className: 'number',\n    variants: [\n      // DecimalLiteral\n      { begin: `(\\\\b(${decimalInteger})((${frac})|\\\\.)?|(${frac}))` +\n        `[eE][+-]?(${decimalDigits})\\\\b` },\n      { begin: `\\\\b(${decimalInteger})\\\\b((${frac})\\\\b|\\\\.)?|(${frac})\\\\b` },\n\n      // DecimalBigIntegerLiteral\n      { begin: `\\\\b(0|[1-9](_?[0-9])*)n\\\\b` },\n\n      // NonDecimalIntegerLiteral\n      { begin: \"\\\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\\\b\" },\n      { begin: \"\\\\b0[bB][0-1](_?[0-1])*n?\\\\b\" },\n      { begin: \"\\\\b0[oO][0-7](_?[0-7])*n?\\\\b\" },\n\n      // LegacyOctalIntegerLiteral (does not include underscore separators)\n      // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals\n      { begin: \"\\\\b0[0-7]+n?\\\\b\" },\n    ],\n    relevance: 0\n  };\n\n  const SUBST = {\n    className: 'subst',\n    begin: '\\\\$\\\\{',\n    end: '\\\\}',\n    keywords: KEYWORDS$1,\n    contains: [] // defined later\n  };\n  const HTML_TEMPLATE = {\n    begin: 'html`',\n    end: '',\n    starts: {\n      end: '`',\n      returnEnd: false,\n      contains: [\n        hljs.BACKSLASH_ESCAPE,\n        SUBST\n      ],\n      subLanguage: 'xml'\n    }\n  };\n  const CSS_TEMPLATE = {\n    begin: 'css`',\n    end: '',\n    starts: {\n      end: '`',\n      returnEnd: false,\n      contains: [\n        hljs.BACKSLASH_ESCAPE,\n        SUBST\n      ],\n      subLanguage: 'css'\n    }\n  };\n  const TEMPLATE_STRING = {\n    className: 'string',\n    begin: '`',\n    end: '`',\n    contains: [\n      hljs.BACKSLASH_ESCAPE,\n      SUBST\n    ]\n  };\n  const JSDOC_COMMENT = hljs.COMMENT(\n    /\\/\\*\\*(?!\\/)/,\n    '\\\\*/',\n    {\n      relevance: 0,\n      contains: [\n        {\n          className: 'doctag',\n          begin: '@[A-Za-z]+',\n          contains: [\n            {\n              className: 'type',\n              begin: '\\\\{',\n              end: '\\\\}',\n              relevance: 0\n            },\n            {\n              className: 'variable',\n              begin: IDENT_RE$1 + '(?=\\\\s*(-)|$)',\n              endsParent: true,\n              relevance: 0\n            },\n            // eat spaces (not newlines) so we can find\n            // types or variables\n            {\n              begin: /(?=[^\\n])\\s/,\n              relevance: 0\n            }\n          ]\n        }\n      ]\n    }\n  );\n  const COMMENT = {\n    className: \"comment\",\n    variants: [\n      JSDOC_COMMENT,\n      hljs.C_BLOCK_COMMENT_MODE,\n      hljs.C_LINE_COMMENT_MODE\n    ]\n  };\n  const SUBST_INTERNALS = [\n    hljs.APOS_STRING_MODE,\n    hljs.QUOTE_STRING_MODE,\n    HTML_TEMPLATE,\n    CSS_TEMPLATE,\n    TEMPLATE_STRING,\n    NUMBER,\n    hljs.REGEXP_MODE\n  ];\n  SUBST.contains = SUBST_INTERNALS\n    .concat({\n      // we need to pair up {} inside our subst to prevent\n      // it from ending too early by matching another }\n      begin: /\\{/,\n      end: /\\}/,\n      keywords: KEYWORDS$1,\n      contains: [\n        \"self\"\n      ].concat(SUBST_INTERNALS)\n    });\n  const SUBST_AND_COMMENTS = [].concat(COMMENT, SUBST.contains);\n  const PARAMS_CONTAINS = SUBST_AND_COMMENTS.concat([\n    // eat recursive parens in sub expressions\n    {\n      begin: /\\(/,\n      end: /\\)/,\n      keywords: KEYWORDS$1,\n      contains: [\"self\"].concat(SUBST_AND_COMMENTS)\n    }\n  ]);\n  const PARAMS = {\n    className: 'params',\n    begin: /\\(/,\n    end: /\\)/,\n    excludeBegin: true,\n    excludeEnd: true,\n    keywords: KEYWORDS$1,\n    contains: PARAMS_CONTAINS\n  };\n\n  return {\n    name: 'Javascript',\n    aliases: ['js', 'jsx', 'mjs', 'cjs'],\n    keywords: KEYWORDS$1,\n    // this will be extended by TypeScript\n    exports: { PARAMS_CONTAINS },\n    illegal: /#(?![$_A-z])/,\n    contains: [\n      hljs.SHEBANG({\n        label: \"shebang\",\n        binary: \"node\",\n        relevance: 5\n      }),\n      {\n        label: \"use_strict\",\n        className: 'meta',\n        relevance: 10,\n        begin: /^\\s*['\"]use (strict|asm)['\"]/\n      },\n      hljs.APOS_STRING_MODE,\n      hljs.QUOTE_STRING_MODE,\n      HTML_TEMPLATE,\n      CSS_TEMPLATE,\n      TEMPLATE_STRING,\n      COMMENT,\n      NUMBER,\n      { // object attr container\n        begin: concat(/[{,\\n]\\s*/,\n          // we need to look ahead to make sure that we actually have an\n          // attribute coming up so we don't steal a comma from a potential\n          // \"value\" container\n          //\n          // NOTE: this might not work how you think.  We don't actually always\n          // enter this mode and stay.  Instead it might merely match `,\n          // <comments up next>` and then immediately end after the , because it\n          // fails to find any actual attrs. But this still does the job because\n          // it prevents the value contain rule from grabbing this instead and\n          // prevening this rule from firing when we actually DO have keys.\n          lookahead(concat(\n            // we also need to allow for multiple possible comments inbetween\n            // the first key:value pairing\n            /(((\\/\\/.*$)|(\\/\\*(\\*[^/]|[^*])*\\*\\/))\\s*)*/,\n            IDENT_RE$1 + '\\\\s*:'))),\n        relevance: 0,\n        contains: [\n          {\n            className: 'attr',\n            begin: IDENT_RE$1 + lookahead('\\\\s*:'),\n            relevance: 0\n          }\n        ]\n      },\n      { // \"value\" container\n        begin: '(' + hljs.RE_STARTERS_RE + '|\\\\b(case|return|throw)\\\\b)\\\\s*',\n        keywords: 'return throw case',\n        contains: [\n          COMMENT,\n          hljs.REGEXP_MODE,\n          {\n            className: 'function',\n            // we have to count the parens to make sure we actually have the\n            // correct bounding ( ) before the =>.  There could be any number of\n            // sub-expressions inside also surrounded by parens.\n            begin: '(\\\\(' +\n            '[^()]*(\\\\(' +\n            '[^()]*(\\\\(' +\n            '[^()]*' +\n            '\\\\)[^()]*)*' +\n            '\\\\)[^()]*)*' +\n            '\\\\)|' + hljs.UNDERSCORE_IDENT_RE + ')\\\\s*=>',\n            returnBegin: true,\n            end: '\\\\s*=>',\n            contains: [\n              {\n                className: 'params',\n                variants: [\n                  {\n                    begin: hljs.UNDERSCORE_IDENT_RE,\n                    relevance: 0\n                  },\n                  {\n                    className: null,\n                    begin: /\\(\\s*\\)/,\n                    skip: true\n                  },\n                  {\n                    begin: /\\(/,\n                    end: /\\)/,\n                    excludeBegin: true,\n                    excludeEnd: true,\n                    keywords: KEYWORDS$1,\n                    contains: PARAMS_CONTAINS\n                  }\n                ]\n              }\n            ]\n          },\n          { // could be a comma delimited list of params to a function call\n            begin: /,/, relevance: 0\n          },\n          {\n            className: '',\n            begin: /\\s/,\n            end: /\\s*/,\n            skip: true\n          },\n          { // JSX\n            variants: [\n              { begin: FRAGMENT.begin, end: FRAGMENT.end },\n              {\n                begin: XML_TAG.begin,\n                // we carefully check the opening tag to see if it truly\n                // is a tag and not a false positive\n                'on:begin': XML_TAG.isTrulyOpeningTag,\n                end: XML_TAG.end\n              }\n            ],\n            subLanguage: 'xml',\n            contains: [\n              {\n                begin: XML_TAG.begin,\n                end: XML_TAG.end,\n                skip: true,\n                contains: ['self']\n              }\n            ]\n          }\n        ],\n        relevance: 0\n      },\n      {\n        className: 'function',\n        beginKeywords: 'function',\n        end: /[{;]/,\n        excludeEnd: true,\n        keywords: KEYWORDS$1,\n        contains: [\n          'self',\n          hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE$1 }),\n          PARAMS\n        ],\n        illegal: /%/\n      },\n      {\n        // prevent this from getting swallowed up by function\n        // since they appear \"function like\"\n        beginKeywords: \"while if switch catch for\"\n      },\n      {\n        className: 'function',\n        // we have to count the parens to make sure we actually have the correct\n        // bounding ( ).  There could be any number of sub-expressions inside\n        // also surrounded by parens.\n        begin: hljs.UNDERSCORE_IDENT_RE +\n          '\\\\(' + // first parens\n          '[^()]*(\\\\(' +\n            '[^()]*(\\\\(' +\n              '[^()]*' +\n            '\\\\)[^()]*)*' +\n          '\\\\)[^()]*)*' +\n          '\\\\)\\\\s*\\\\{', // end parens\n        returnBegin:true,\n        contains: [\n          PARAMS,\n          hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE$1 }),\n        ]\n      },\n      // hack: prevents detection of keywords in some circumstances\n      // .keyword()\n      // $keyword = x\n      {\n        variants: [\n          { begin: '\\\\.' + IDENT_RE$1 },\n          { begin: '\\\\$' + IDENT_RE$1 }\n        ],\n        relevance: 0\n      },\n      { // ES6 class\n        className: 'class',\n        beginKeywords: 'class',\n        end: /[{;=]/,\n        excludeEnd: true,\n        illegal: /[:\"[\\]]/,\n        contains: [\n          { beginKeywords: 'extends' },\n          hljs.UNDERSCORE_TITLE_MODE\n        ]\n      },\n      {\n        begin: /\\b(?=constructor)/,\n        end: /[{;]/,\n        excludeEnd: true,\n        contains: [\n          hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE$1 }),\n          'self',\n          PARAMS\n        ]\n      },\n      {\n        begin: '(get|set)\\\\s+(?=' + IDENT_RE$1 + '\\\\()',\n        end: /\\{/,\n        keywords: \"get set\",\n        contains: [\n          hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE$1 }),\n          { begin: /\\(\\)/ }, // eat to avoid empty params\n          PARAMS\n        ]\n      },\n      {\n        begin: /\\$[(.]/ // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`\n      }\n    ]\n  };\n}\n\n/*\nLanguage: TypeScript\nAuthor: Panu Horsmalahti <panu.horsmalahti@iki.fi>\nContributors: Ike Ku <dempfi@yahoo.com>\nDescription: TypeScript is a strict superset of JavaScript\nWebsite: https://www.typescriptlang.org\nCategory: common, scripting\n*/\n\n/** @type LanguageFn */\nfunction typescript(hljs) {\n  const IDENT_RE$1 = IDENT_RE;\n  const NAMESPACE = {\n    beginKeywords: 'namespace', end: /\\{/, excludeEnd: true\n  };\n  const INTERFACE = {\n    beginKeywords: 'interface', end: /\\{/, excludeEnd: true,\n    keywords: 'interface extends'\n  };\n  const USE_STRICT = {\n    className: 'meta',\n    relevance: 10,\n    begin: /^\\s*['\"]use strict['\"]/\n  };\n  const TYPES = [\n    \"any\",\n    \"void\",\n    \"number\",\n    \"boolean\",\n    \"string\",\n    \"object\",\n    \"never\",\n    \"enum\"\n  ];\n  const TS_SPECIFIC_KEYWORDS = [\n    \"type\",\n    \"namespace\",\n    \"typedef\",\n    \"interface\",\n    \"public\",\n    \"private\",\n    \"protected\",\n    \"implements\",\n    \"declare\",\n    \"abstract\",\n    \"readonly\"\n  ];\n  const KEYWORDS$1 = {\n    $pattern: IDENT_RE,\n    keyword: KEYWORDS.concat(TS_SPECIFIC_KEYWORDS),\n    literal: LITERALS,\n    built_in: BUILT_INS.concat(TYPES)\n  };\n  const DECORATOR = {\n    className: 'meta',\n    begin: '@' + IDENT_RE$1,\n  };\n\n  const swapMode = (mode, label, replacement) => {\n    const indx = mode.contains.findIndex(m => m.label === label);\n    if (indx === -1) { throw new Error(\"can not find mode to replace\"); }\n    mode.contains.splice(indx, 1, replacement);\n  };\n\n  const tsLanguage = javascript(hljs);\n\n  // this should update anywhere keywords is used since\n  // it will be the same actual JS object\n  Object.assign(tsLanguage.keywords, KEYWORDS$1);\n\n  tsLanguage.exports.PARAMS_CONTAINS.push(DECORATOR);\n  tsLanguage.contains = tsLanguage.contains.concat([\n    DECORATOR,\n    NAMESPACE,\n    INTERFACE,\n  ]);\n\n  // TS gets a simpler shebang rule than JS\n  swapMode(tsLanguage, \"shebang\", hljs.SHEBANG());\n  // JS use strict rule purposely excludes `asm` which makes no sense\n  swapMode(tsLanguage, \"use_strict\", USE_STRICT);\n\n  const functionDeclaration = tsLanguage.contains.find(m => m.className === \"function\");\n  functionDeclaration.relevance = 0; // () => {} is more typical in TypeScript\n\n  Object.assign(tsLanguage, {\n    name: 'TypeScript',\n    aliases: ['ts', 'tsx']\n  });\n\n  return tsLanguage;\n}\n\nmodule.exports = typescript;\n"]},"metadata":{},"sourceType":"script"}